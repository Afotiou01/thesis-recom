<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BookingArts â€“ Event Recommender Demo</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body { margin:0; font-family:system-ui; background:linear-gradient(135deg,#4f46e5,#020617); color:#111827; }
.container { max-width:1000px; margin:auto; padding:32px 16px; }
.card { background:#f9fafb; border-radius:16px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.35); margin-bottom:24px; }
h1 { background:linear-gradient(to right,#4f46e5,#ec4899); -webkit-background-clip:text; color:transparent; }
label { font-size:.9rem; font-weight:600; display:block; margin-top:12px; }
input, select, button { width:100%; padding:10px; margin-top:6px; border-radius:8px; border:1px solid #d1d5db; }
button { margin-top:18px; background:linear-gradient(to right,#4f46e5,#6366f1); color:#fff; border:none; cursor:pointer; font-weight:600; }
.row { display:grid; grid-template-columns:1fr 1fr; gap:14px; }
@media (max-width:700px){ .row{ grid-template-columns:1fr; } }
.event { background:#fff; border-radius:12px; padding:14px; margin-bottom:10px; border-left:4px solid #4f46e5; }
.event-title { font-weight:700; }
.event-meta { font-size:.8rem; color:#6b7280; }
.score { font-size:.85rem; margin-top:6px; color:#374151; }
.explain { font-size:.8rem; color:#6b7280; font-style:italic; margin-top:6px; }
.badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#4338ca; font-size:.75rem; margin-right:6px; }
small { color:#6b7280; }
</style>
</head>
<body>
<div class="container">

  <div class="card">
    <h1>BookingArts Recommender</h1>
    <p>Onboarding â†’ Content + Context + Artist + Language â†’ Top results. <strong>Scores shown for research.</strong></p>
    <small id="apiStatus"></small>
  </div>

  <div class="card">
    <h2>User Profile</h2>

    <div class="row">
      <div>
        <label>Username</label>
        <input id="username" value="demo_user">
      </div>
      <div>
        <label>City</label>
        <select id="city">
          <option>Nicosia</option>
          <option>Limassol</option>
          <option>Larnaca</option>
          <option>Paphos</option>
        </select>
      </div>
    </div>

    <label>Music language</label>
    <select id="language">
      <option value="lang_greek">Greek</option>
      <option value="lang_english">English</option>
      <option value="both">Both</option>
    </select>

    <label>Music tags (from DB)</label>
    <select id="tags" multiple size="10"></select>
    <small>Tags shown depend on DB + chosen language.</small>

    <label>Favourite artists (from DB)</label>
    <select id="artists" multiple size="6"></select>

    <button id="saveBtn" onclick="saveProfile()">Save Profile</button>
    <small id="saveStatus"></small>
  </div>

  <div class="card">
    <h2>Get Recommendations</h2>

    <div class="row">
      <div>
        <label>From date</label>
        <input type="date" id="from">
      </div>
      <div>
        <label>To date</label>
        <input type="date" id="to">
      </div>
    </div>

    <label>Experiment mode (A/B)</label>
    <select id="mode">
      <option value="hybrid">Hybrid (CBF + Context + Artist + Language)</option>
      <option value="baseline">Baseline (CBF only)</option>
    </select>

    <label style="margin-top:14px;">Diversify feed (5 ranked + 1 random)</label>
    <select id="diversify">
      <option value="true">On</option>
      <option value="false">Off</option>
    </select>

    <div style="margin-top:14px;">
      <h3 style="margin:0 0 6px;">Tuning (for research)</h3>

      <label>CBF weight: <span id="cbfVal">0.6</span></label>
      <input type="range" id="w_cbf" min="0" max="1" step="0.05" value="0.6">

      <label>Context weight: <span id="ctxVal">0.4</span></label>
      <input type="range" id="w_context" min="0" max="1" step="0.05" value="0.4">

      <label>Max Artist Boost: <span id="boostVal">0.3</span></label>
      <input type="range" id="max_artist_boost" min="0" max="1" step="0.05" value="0.3">

      <label>Language weight: <span id="langVal">0.15</span></label>
      <input type="range" id="w_language" min="0" max="1" step="0.05" value="0.15">

      <button onclick="saveWeights()">Save Weights</button>
      <small id="weightsStatus"></small>
    </div>

    <button id="recBtn" onclick="getRecs()">Get Events</button>
    <div id="results"></div>
  </div>

</div>

<script>
const API = "/api";
const qs = (id) => document.getElementById(id);

let DYNAMIC = { tags: [], artists: [], tag_groups: { greek_only: [], english_only: [] } };

/** Check API reachability */
async function checkApi() {
  try {
    const res = await fetch(API + "/options");
    if (!res.ok) throw new Error("bad");
    qs("apiStatus").textContent = "API connected.";
  } catch {
    qs("apiStatus").textContent = "API not reachable.";
  }
}

/** Utility: get selected values from multi-select */
function selectedValues(selectEl) {
  return Array.from(selectEl.selectedOptions).map(o => o.value);
}

/** Utility: set options inside select */
function setSelectOptions(selectEl, values) {
  selectEl.innerHTML = "";
  values.forEach(v => {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    selectEl.appendChild(opt);
  });
}

/** Current language preference */
function getLanguageMode() {
  return qs("language").value;
}

/** Filter tag options based on chosen language (hide Laiko etc on English) */
function filterTagsByLanguage(allTags) {
  const mode = getLanguageMode();
  const greekOnly = new Set((DYNAMIC.tag_groups?.greek_only || []).map(x => x.toLowerCase()));
  const englishOnly = new Set((DYNAMIC.tag_groups?.english_only || []).map(x => x.toLowerCase()));
  const hidden = new Set(["lang_greek","lang_english","concert"]);

  return allTags.filter(t => {
    const tl = (t || "").toLowerCase();
    if (hidden.has(tl)) return false;
    if (mode === "lang_english") return !greekOnly.has(tl);
    if (mode === "lang_greek") return !englishOnly.has(tl);
    return true;
  });
}

/** Load dynamic tags/artists from DB */
async function loadDynamicOptions() {
  const res = await fetch(API + "/options");
  const data = await res.json();

  DYNAMIC.tags = data.tags || [];
  DYNAMIC.artists = data.artists || [];
  DYNAMIC.tag_groups = data.tag_groups || { greek_only: [], english_only: [] };

  setSelectOptions(qs("artists"), DYNAMIC.artists);
  setSelectOptions(qs("tags"), filterTagsByLanguage(DYNAMIC.tags));
}

/** Re-render tags when language changes while preserving selections */
function onLanguageChange() {
  const currentSelected = new Set(selectedValues(qs("tags")).map(x => x.toLowerCase()));
  const tagsForUi = filterTagsByLanguage(DYNAMIC.tags);

  setSelectOptions(qs("tags"), tagsForUi);
  Array.from(qs("tags").options).forEach(opt => {
    if (currentSelected.has(opt.value.toLowerCase())) opt.selected = true;
  });
}
qs("language").addEventListener("change", onLanguageChange);

/** Slider label refresh */
function syncWeightLabels() {
  qs("cbfVal").textContent = qs("w_cbf").value;
  qs("ctxVal").textContent = qs("w_context").value;
  qs("boostVal").textContent = qs("max_artist_boost").value;
  qs("langVal").textContent = qs("w_language").value;
}
["w_cbf","w_context","max_artist_boost","w_language"].forEach(id => {
  document.addEventListener("input", (e) => {
    if (e.target && e.target.id === id) syncWeightLabels();
  });
});

/** Load weights from backend */
async function loadWeights() {
  const res = await fetch(API + "/config/weights");
  const w = await res.json();
  qs("w_cbf").value = w.w_cbf;
  qs("w_context").value = w.w_context;
  qs("max_artist_boost").value = w.max_artist_boost;
  qs("w_language").value = w.w_language;
  syncWeightLabels();
}

/** Save weights to backend */
async function saveWeights() {
  qs("weightsStatus").textContent = "";

  const w_cbf = parseFloat(qs("w_cbf").value);
  const w_context = parseFloat(qs("w_context").value);
  const max_artist_boost = parseFloat(qs("max_artist_boost").value);
  const w_language = parseFloat(qs("w_language").value);

  if (Math.abs((w_cbf + w_context) - 1.0) > 1e-6) {
    qs("weightsStatus").textContent = "CBF + Context must equal 1.0";
    return;
  }

  const res = await fetch(API + "/config/weights", {
    method: "PUT",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ w_cbf, w_context, max_artist_boost, w_language })
  });

  if (!res.ok) {
    const err = await res.json().catch(() => ({}));
    qs("weightsStatus").textContent = "Error: " + (err.detail || "Could not save weights.");
    return;
  }

  qs("weightsStatus").textContent = "Weights saved.";
}

/** Save user profile to DB */
async function saveProfile() {
  qs("saveStatus").textContent = "";

  const username = qs("username").value.trim();
  const city = qs("city").value;
  if (!username) {
    qs("saveStatus").textContent = "Enter a username.";
    return;
  }

  const tags = selectedValues(qs("tags"));
  const favArtists = selectedValues(qs("artists"));

  const langMode = getLanguageMode();
  const finalTags = ["concert", ...tags];
  if (langMode !== "both") finalTags.push(langMode);
  else finalTags.push("lang_greek","lang_english");

  qs("saveBtn").disabled = true;
  try {
    const res = await fetch(API + "/users/profile", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ username, city, tags: finalTags, favorite_artists: favArtists })
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      qs("saveStatus").textContent = "Error: " + (err.detail || "Could not save profile.");
      return;
    }

    qs("saveStatus").textContent = "Profile saved.";
    alert("Profile saved");
  } finally {
    qs("saveBtn").disabled = false;
  }
}

/** Fetch recommendations and render them */
async function getRecs() {
  const username = qs("username").value.trim();
  if (!username) { alert("Enter username first."); return; }

  const params = new URLSearchParams();
  params.set("username", username);

  const f = qs("from").value;
  const t = qs("to").value;
  if (f) params.set("date_from", f);
  if (t) params.set("date_to", t);

  params.set("mode", qs("mode").value);

  const diversify = qs("diversify").value === "true";
  params.set("diversify", diversify ? "true" : "false");
  if (diversify) {
    params.set("random_every", "5");
    params.set("random_count", "1");
  }

  qs("recBtn").disabled = true;
  try {
    const res = await fetch(API + "/recommendations?" + params.toString());
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      alert(err.detail || "Could not fetch recommendations.");
      return;
    }

    const data = await res.json();
    const results = data.results || [];
    const div = qs("results");
    div.innerHTML = "";

    if (!results.length) {
      div.innerHTML = `<div class="event"><div class="event-title">No events found.</div></div>`;
      return;
    }

    results.forEach(ev => {
      const randomBadge = ev.is_random_insertion ? `<span class="badge">ðŸŽ² Random</span>` : "";
      div.innerHTML += `
        <div class="event">
          <div class="event-title">${ev.title}</div>
          <div class="event-meta">${ev.city} Â· ${ev.date} Â· ${ev.language}</div>
          <div class="score">
            ${randomBadge}
            <span class="badge">Score ${ev.score}</span>
            CBF: ${ev.breakdown.cbf},
            Context: ${ev.breakdown.context},
            Artist: ${ev.breakdown.artist_boost},
            LangTerm: ${ev.breakdown.language_term}
          </div>
          <div class="explain">
            ${ev.explanation}
            <br><strong>Matched tags:</strong> ${(ev.why.matched_tags || []).join(", ") || "-"}
            <br><strong>Matched artists:</strong> ${(ev.why.matched_artists || []).join(", ") || "-"}
          </div>
        </div>
      `;
    });
  } finally {
    qs("recBtn").disabled = false;
  }
}

(async function init(){
  await checkApi();
  await loadDynamicOptions();
  await loadWeights();
  syncWeightLabels();
})();
</script>
</body>
</html>
